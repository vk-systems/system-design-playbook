[
    {
        "id": "global-sequencer",
        "title": "Global Sequencer",
        "category": "Distributed",
        "icon": "cpu",
        "description": "High-throughput unique ID generation at 12.5M IDs/second with Twitter's Snowflake algorithm.",
        "tags": ["distributed-systems", "scalability", "database", "unique-ids", "snowflake"],
        "difficulty": "intermediate",
        "estimatedReadTime": "15 min",
        "stack": ["Snowflake", "ZooKeeper", "RocksDB", "gRPC"],
        "metadata": {
            "dateAdded": "2026-01-14",
            "source": "Twitter's Snowflake + Production Experience",
            "prerequisites": [],
            "adrNumber": "ADR-001",
            "status": "Production",
            "cost": "$8K/month",
            "throughput": "12.5M TPS"
        },
        "stats": {
            "throughput": "12.5M IDs/sec",
            "latency": "0.8ms P99",
            "cost": "$8K/month",
            "savings": "$37K/month vs managed"
        },
        "adr": {
            "problem": "Generate globally unique, time-ordered 64-bit IDs at 10M+ TPS across multiple regions with sub-millisecond latency and high availability.",
            "context": "Distributed transaction system handling 864 billion transactions/day across 50+ microservices. Must survive datacenter failures while maintaining uniqueness guarantees.",
            "decision": "Twitter's Snowflake Algorithm with ZooKeeper coordination, RocksDB audit log, and gRPC transport. 9 sequencer nodes (3 per region) generating IDs locally without central coordination.",
            "alternatives": "UUIDv4 (2× storage cost), Database Auto-Increment (28K TPS max), Centralized ID Service (adds network latency), MongoDB ObjectID (not time-sortable)",
            "consequences": "✅ Achieved 12.5M TPS with 0.8ms P99 latency. ✅ Saves $444K/year vs managed service. ❌ Clock dependency risk (2 incidents in 6 months). ❌ ZooKeeper dependency for machine ID assignment.",
            "filePath": "Systems/global-sequencer/ADR-001-Distributed-ID-Generation.md"
        },
        "relatedConcepts": ["distributed-consensus", "lsm-tree", "time-ordering"]
    },
    {
        "id": "distributed-consensus",
        "title": "Distributed Consensus",
        "category": "Consistency",
        "icon": "users",
        "description": "Ensuring state machine consistency across distributed nodes via the Raft algorithm.",
        "tags": ["consensus", "distributed-systems", "fault-tolerance", "raft"],
        "difficulty": "advanced",
        "estimatedReadTime": "10 min",
        "stack": ["Raft", "Quorum"],
        "metadata": {
            "dateAdded": "2026-01-05",
            "source": "Raft Paper - Diego Ongaro",
            "prerequisites": []
        },
        "adr": {
            "problem": "How do nodes agree on values in a cluster where any node can fail at any time?",
            "context": "Consensus ensures that a majority of nodes agree on the state before it is considered 'committed'.",
            "decision": "Utilize the Raft algorithm for its formal safety guarantees and developer understandability.",
            "architecture": "Leaders manage the log and heartbeat followers. If a leader fails, a new term begins.",
            "consequences": "Guarantees strong consistency at the cost of majority network latency."
        },
        "externalLinks": [
            {
                "name": "The Raft Consensus Algorithm Official Site",
                "url": "https://raft.github.io/"
            }
        ],
        "relatedConcepts": ["global-sequencer"]
    },
    {
        "id": "bloom-filter",
        "title": "Bloom Filter",
        "category": "Storage",
        "icon": "filter",
        "description": "Probabilistic set membership to avoid unnecessary expensive disk seeks in LSM storage.",
        "tags": ["data-structures", "probabilistic", "storage", "optimization"],
        "difficulty": "beginner",
        "estimatedReadTime": "5 min",
        "stack": ["Hashing", "Bitset"],
        "metadata": {
            "dateAdded": "2026-01-05",
            "source": "Database Internals Book",
            "prerequisites": []
        },
        "adr": {
            "problem": "Checking if a key exists in an <span class='inline-link' onclick='showDetail(\"lsm-tree\")'>LSM-Tree</span> is expensive due to multiple disk seeks.",
            "context": "Disk I/O is the primary bottleneck for reads in write-heavy storage engines.",
            "decision": "Implement a Bloom Filter in RAM to provide a probabilistic existence check.",
            "architecture": "Uses k-independent hash functions to map values to a bitset of size m.",
            "consequences": "Sub-millisecond membership testing with extremely low memory footprint."
        },
        "externalLinks": [
            {
                "name": "Cloudflare: When Bloom Filters don't bloom",
                "url": "https://blog.cloudflare.com/when-bloom-filters-dont-bloom/"
            }
        ],
        "relatedConcepts": ["lsm-tree"]
    },
    {
        "id": "lsm-tree",
        "title": "LSM-Tree Storage",
        "category": "Persistence",
        "icon": "database",
        "description": "Write-optimized storage engine designed for high-throughput sequential inserts.",
        "tags": ["storage-engine", "database", "write-optimization", "data-structures"],
        "difficulty": "intermediate",
        "estimatedReadTime": "12 min",
        "stack": ["Memtable", "SSTables"],
        "metadata": {
            "dateAdded": "2026-01-05",
            "source": "Designing Data-Intensive Applications",
            "prerequisites": []
        },
        "adr": {
            "problem": "How do we handle high-volume random writes without fragmenting the database index?",
            "context": "B-Trees require expensive random I/O for updates, which kills performance.",
            "decision": "Adopt a Log-Structured Merge-Tree approach. Updates are buffered in memory and flushed sequentially.",
            "architecture": "Multiple levels of immutable SSTables are merged via background compaction.",
            "consequences": "Exceptional write throughput for sequence persistence on modern SSDs."
        },
        "externalLinks": [
            {
                "name": "Cassandra Architecture: Storage Engine",
                "url": "https://cassandra.apache.org/doc/stable/cassandra/architecture/storage-engine.html"
            }
        ],
        "relatedConcepts": ["bloom-filter", "global-sequencer"]
    }
]
